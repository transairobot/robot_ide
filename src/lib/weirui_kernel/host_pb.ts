// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v3.21.12
// source: src/lib/weirui_kernel/host_pb.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "";

export enum ActuatorType {
  DUMMY = 0,
  MOTOR = 1,
  POSITION = 2,
  UNRECOGNIZED = -1,
}

export function actuatorTypeFromJSON(object: any): ActuatorType {
  switch (object) {
    case 0:
    case "DUMMY":
      return ActuatorType.DUMMY;
    case 1:
    case "MOTOR":
      return ActuatorType.MOTOR;
    case 2:
    case "POSITION":
      return ActuatorType.POSITION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ActuatorType.UNRECOGNIZED;
  }
}

export function actuatorTypeToJSON(object: ActuatorType): string {
  switch (object) {
    case ActuatorType.DUMMY:
      return "DUMMY";
    case ActuatorType.MOTOR:
      return "MOTOR";
    case ActuatorType.POSITION:
      return "POSITION";
    case ActuatorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum JointType {
  HINGE = 0,
  SLIDE = 1,
  BALL = 2,
  FREE = 3,
  UNRECOGNIZED = -1,
}

export function jointTypeFromJSON(object: any): JointType {
  switch (object) {
    case 0:
    case "HINGE":
      return JointType.HINGE;
    case 1:
    case "SLIDE":
      return JointType.SLIDE;
    case 2:
    case "BALL":
      return JointType.BALL;
    case 3:
    case "FREE":
      return JointType.FREE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return JointType.UNRECOGNIZED;
  }
}

export function jointTypeToJSON(object: JointType): string {
  switch (object) {
    case JointType.HINGE:
      return "HINGE";
    case JointType.SLIDE:
      return "SLIDE";
    case JointType.BALL:
      return "BALL";
    case JointType.FREE:
      return "FREE";
    case JointType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Unified result wrapper for all host function responses */
export interface HostResult {
  /** 0 = success, non-zero = error */
  errorCode?:
    | number
    | undefined;
  /** Human-readable error description */
  errorMessage?:
    | string
    | undefined;
  /** Serialized response data (specific message type) */
  data?: Uint8Array | undefined;
}

export interface RunTargetActionReq {
  servoIdVec: number[];
  targetRadVec: number[];
}

export interface RunTargetActionResp {
  servoIdVec: number[];
  targetRadVec: number[];
}

export interface ActuatorInfo {
  name?: string | undefined;
  id?: number | undefined;
  type?: ActuatorType | undefined;
  vendor?: string | undefined;
  model?: string | undefined;
  ctrl?: number | undefined;
  ctrlMin?: number | undefined;
  ctrlMax?: number | undefined;
  forceMin?: number | undefined;
  forceMax?: number | undefined;
  jointId?: number | undefined;
}

/** This request is empty */
export interface GetActuatorInfoReq {
}

export interface GetActuatorInfoResp {
  actuators: ActuatorInfo[];
}

export interface JointInfo {
  name?: string | undefined;
  id?: number | undefined;
  type?: JointType | undefined;
  dofDim?: number | undefined;
  jointPos: number[];
}

/** This request is empty */
export interface GetJointInfoReq {
}

export interface GetJointInfoResp {
  joints: JointInfo[];
}

export interface ConsoleWriteReq {
  message?: string | undefined;
}

function createBaseHostResult(): HostResult {
  return { errorCode: 0, errorMessage: "", data: new Uint8Array(0) };
}

export const HostResult: MessageFns<HostResult> = {
  encode(message: HostResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      writer.uint32(8).int32(message.errorCode);
    }
    if (message.errorMessage !== undefined && message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.data !== undefined && message.data.length !== 0) {
      writer.uint32(26).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HostResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHostResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.errorCode = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HostResult {
    return {
      errorCode: isSet(object.errorCode) ? gt.Number(object.errorCode) : 0,
      errorMessage: isSet(object.errorMessage) ? gt.String(object.errorMessage) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
    };
  },

  toJSON(message: HostResult): unknown {
    const obj: any = {};
    if (message.errorCode !== undefined && message.errorCode !== 0) {
      obj.errorCode = Math.round(message.errorCode);
    }
    if (message.errorMessage !== undefined && message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.data !== undefined && message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HostResult>, I>>(base?: I): HostResult {
    return HostResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HostResult>, I>>(object: I): HostResult {
    const message = createBaseHostResult();
    message.errorCode = object.errorCode ?? 0;
    message.errorMessage = object.errorMessage ?? "";
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseRunTargetActionReq(): RunTargetActionReq {
  return { servoIdVec: [], targetRadVec: [] };
}

export const RunTargetActionReq: MessageFns<RunTargetActionReq> = {
  encode(message: RunTargetActionReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.servoIdVec) {
      writer.uint32(8).uint32(v!);
    }
    for (const v of message.targetRadVec) {
      writer.uint32(21).float(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunTargetActionReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunTargetActionReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.servoIdVec.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.servoIdVec.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag === 21) {
            message.targetRadVec.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.targetRadVec.push(reader.float());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunTargetActionReq {
    return {
      servoIdVec: gt.Array.isArray(object?.servoIdVec) ? object.servoIdVec.map((e: any) => gt.Number(e)) : [],
      targetRadVec: gt.Array.isArray(object?.targetRadVec) ? object.targetRadVec.map((e: any) => gt.Number(e)) : [],
    };
  },

  toJSON(message: RunTargetActionReq): unknown {
    const obj: any = {};
    if (message.servoIdVec?.length) {
      obj.servoIdVec = message.servoIdVec.map((e) => Math.round(e));
    }
    if (message.targetRadVec?.length) {
      obj.targetRadVec = message.targetRadVec;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunTargetActionReq>, I>>(base?: I): RunTargetActionReq {
    return RunTargetActionReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunTargetActionReq>, I>>(object: I): RunTargetActionReq {
    const message = createBaseRunTargetActionReq();
    message.servoIdVec = object.servoIdVec?.map((e) => e) || [];
    message.targetRadVec = object.targetRadVec?.map((e) => e) || [];
    return message;
  },
};

function createBaseRunTargetActionResp(): RunTargetActionResp {
  return { servoIdVec: [], targetRadVec: [] };
}

export const RunTargetActionResp: MessageFns<RunTargetActionResp> = {
  encode(message: RunTargetActionResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.servoIdVec) {
      writer.uint32(8).uint32(v!);
    }
    for (const v of message.targetRadVec) {
      writer.uint32(21).float(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunTargetActionResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunTargetActionResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.servoIdVec.push(reader.uint32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.servoIdVec.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag === 21) {
            message.targetRadVec.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.targetRadVec.push(reader.float());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunTargetActionResp {
    return {
      servoIdVec: gt.Array.isArray(object?.servoIdVec) ? object.servoIdVec.map((e: any) => gt.Number(e)) : [],
      targetRadVec: gt.Array.isArray(object?.targetRadVec) ? object.targetRadVec.map((e: any) => gt.Number(e)) : [],
    };
  },

  toJSON(message: RunTargetActionResp): unknown {
    const obj: any = {};
    if (message.servoIdVec?.length) {
      obj.servoIdVec = message.servoIdVec.map((e) => Math.round(e));
    }
    if (message.targetRadVec?.length) {
      obj.targetRadVec = message.targetRadVec;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RunTargetActionResp>, I>>(base?: I): RunTargetActionResp {
    return RunTargetActionResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RunTargetActionResp>, I>>(object: I): RunTargetActionResp {
    const message = createBaseRunTargetActionResp();
    message.servoIdVec = object.servoIdVec?.map((e) => e) || [];
    message.targetRadVec = object.targetRadVec?.map((e) => e) || [];
    return message;
  },
};

function createBaseActuatorInfo(): ActuatorInfo {
  return {
    name: "",
    id: 0,
    type: 0,
    vendor: "",
    model: "",
    ctrl: 0,
    ctrlMin: 0,
    ctrlMax: 0,
    forceMin: 0,
    forceMax: 0,
    jointId: 0,
  };
}

export const ActuatorInfo: MessageFns<ActuatorInfo> = {
  encode(message: ActuatorInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(16).int32(message.id);
    }
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.vendor !== undefined && message.vendor !== "") {
      writer.uint32(34).string(message.vendor);
    }
    if (message.model !== undefined && message.model !== "") {
      writer.uint32(42).string(message.model);
    }
    if (message.ctrl !== undefined && message.ctrl !== 0) {
      writer.uint32(53).float(message.ctrl);
    }
    if (message.ctrlMin !== undefined && message.ctrlMin !== 0) {
      writer.uint32(61).float(message.ctrlMin);
    }
    if (message.ctrlMax !== undefined && message.ctrlMax !== 0) {
      writer.uint32(69).float(message.ctrlMax);
    }
    if (message.forceMin !== undefined && message.forceMin !== 0) {
      writer.uint32(77).float(message.forceMin);
    }
    if (message.forceMax !== undefined && message.forceMax !== 0) {
      writer.uint32(85).float(message.forceMax);
    }
    if (message.jointId !== undefined && message.jointId !== 0) {
      writer.uint32(88).int32(message.jointId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActuatorInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActuatorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.vendor = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.model = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.ctrl = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.ctrlMin = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.ctrlMax = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 77) {
            break;
          }

          message.forceMin = reader.float();
          continue;
        }
        case 10: {
          if (tag !== 85) {
            break;
          }

          message.forceMax = reader.float();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.jointId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActuatorInfo {
    return {
      name: isSet(object.name) ? gt.String(object.name) : "",
      id: isSet(object.id) ? gt.Number(object.id) : 0,
      type: isSet(object.type) ? actuatorTypeFromJSON(object.type) : 0,
      vendor: isSet(object.vendor) ? gt.String(object.vendor) : "",
      model: isSet(object.model) ? gt.String(object.model) : "",
      ctrl: isSet(object.ctrl) ? gt.Number(object.ctrl) : 0,
      ctrlMin: isSet(object.ctrlMin) ? gt.Number(object.ctrlMin) : 0,
      ctrlMax: isSet(object.ctrlMax) ? gt.Number(object.ctrlMax) : 0,
      forceMin: isSet(object.forceMin) ? gt.Number(object.forceMin) : 0,
      forceMax: isSet(object.forceMax) ? gt.Number(object.forceMax) : 0,
      jointId: isSet(object.jointId) ? gt.Number(object.jointId) : 0,
    };
  },

  toJSON(message: ActuatorInfo): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== undefined && message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.type !== undefined && message.type !== 0) {
      obj.type = actuatorTypeToJSON(message.type);
    }
    if (message.vendor !== undefined && message.vendor !== "") {
      obj.vendor = message.vendor;
    }
    if (message.model !== undefined && message.model !== "") {
      obj.model = message.model;
    }
    if (message.ctrl !== undefined && message.ctrl !== 0) {
      obj.ctrl = message.ctrl;
    }
    if (message.ctrlMin !== undefined && message.ctrlMin !== 0) {
      obj.ctrlMin = message.ctrlMin;
    }
    if (message.ctrlMax !== undefined && message.ctrlMax !== 0) {
      obj.ctrlMax = message.ctrlMax;
    }
    if (message.forceMin !== undefined && message.forceMin !== 0) {
      obj.forceMin = message.forceMin;
    }
    if (message.forceMax !== undefined && message.forceMax !== 0) {
      obj.forceMax = message.forceMax;
    }
    if (message.jointId !== undefined && message.jointId !== 0) {
      obj.jointId = Math.round(message.jointId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActuatorInfo>, I>>(base?: I): ActuatorInfo {
    return ActuatorInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActuatorInfo>, I>>(object: I): ActuatorInfo {
    const message = createBaseActuatorInfo();
    message.name = object.name ?? "";
    message.id = object.id ?? 0;
    message.type = object.type ?? 0;
    message.vendor = object.vendor ?? "";
    message.model = object.model ?? "";
    message.ctrl = object.ctrl ?? 0;
    message.ctrlMin = object.ctrlMin ?? 0;
    message.ctrlMax = object.ctrlMax ?? 0;
    message.forceMin = object.forceMin ?? 0;
    message.forceMax = object.forceMax ?? 0;
    message.jointId = object.jointId ?? 0;
    return message;
  },
};

function createBaseGetActuatorInfoReq(): GetActuatorInfoReq {
  return {};
}

export const GetActuatorInfoReq: MessageFns<GetActuatorInfoReq> = {
  encode(_: GetActuatorInfoReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActuatorInfoReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActuatorInfoReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetActuatorInfoReq {
    return {};
  },

  toJSON(_: GetActuatorInfoReq): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetActuatorInfoReq>, I>>(base?: I): GetActuatorInfoReq {
    return GetActuatorInfoReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetActuatorInfoReq>, I>>(_: I): GetActuatorInfoReq {
    const message = createBaseGetActuatorInfoReq();
    return message;
  },
};

function createBaseGetActuatorInfoResp(): GetActuatorInfoResp {
  return { actuators: [] };
}

export const GetActuatorInfoResp: MessageFns<GetActuatorInfoResp> = {
  encode(message: GetActuatorInfoResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.actuators) {
      ActuatorInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetActuatorInfoResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetActuatorInfoResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.actuators.push(ActuatorInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetActuatorInfoResp {
    return {
      actuators: gt.Array.isArray(object?.actuators) ? object.actuators.map((e: any) => ActuatorInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetActuatorInfoResp): unknown {
    const obj: any = {};
    if (message.actuators?.length) {
      obj.actuators = message.actuators.map((e) => ActuatorInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetActuatorInfoResp>, I>>(base?: I): GetActuatorInfoResp {
    return GetActuatorInfoResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetActuatorInfoResp>, I>>(object: I): GetActuatorInfoResp {
    const message = createBaseGetActuatorInfoResp();
    message.actuators = object.actuators?.map((e) => ActuatorInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseJointInfo(): JointInfo {
  return { name: "", id: 0, type: 0, dofDim: 0, jointPos: [] };
}

export const JointInfo: MessageFns<JointInfo> = {
  encode(message: JointInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(16).int32(message.id);
    }
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.dofDim !== undefined && message.dofDim !== 0) {
      writer.uint32(32).int32(message.dofDim);
    }
    for (const v of message.jointPos) {
      writer.uint32(45).float(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JointInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJointInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.dofDim = reader.int32();
          continue;
        }
        case 5: {
          if (tag === 45) {
            message.jointPos.push(reader.float());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.jointPos.push(reader.float());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JointInfo {
    return {
      name: isSet(object.name) ? gt.String(object.name) : "",
      id: isSet(object.id) ? gt.Number(object.id) : 0,
      type: isSet(object.type) ? jointTypeFromJSON(object.type) : 0,
      dofDim: isSet(object.dofDim) ? gt.Number(object.dofDim) : 0,
      jointPos: gt.Array.isArray(object?.jointPos) ? object.jointPos.map((e: any) => gt.Number(e)) : [],
    };
  },

  toJSON(message: JointInfo): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== undefined && message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.type !== undefined && message.type !== 0) {
      obj.type = jointTypeToJSON(message.type);
    }
    if (message.dofDim !== undefined && message.dofDim !== 0) {
      obj.dofDim = Math.round(message.dofDim);
    }
    if (message.jointPos?.length) {
      obj.jointPos = message.jointPos;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JointInfo>, I>>(base?: I): JointInfo {
    return JointInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JointInfo>, I>>(object: I): JointInfo {
    const message = createBaseJointInfo();
    message.name = object.name ?? "";
    message.id = object.id ?? 0;
    message.type = object.type ?? 0;
    message.dofDim = object.dofDim ?? 0;
    message.jointPos = object.jointPos?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetJointInfoReq(): GetJointInfoReq {
  return {};
}

export const GetJointInfoReq: MessageFns<GetJointInfoReq> = {
  encode(_: GetJointInfoReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetJointInfoReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetJointInfoReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GetJointInfoReq {
    return {};
  },

  toJSON(_: GetJointInfoReq): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GetJointInfoReq>, I>>(base?: I): GetJointInfoReq {
    return GetJointInfoReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetJointInfoReq>, I>>(_: I): GetJointInfoReq {
    const message = createBaseGetJointInfoReq();
    return message;
  },
};

function createBaseGetJointInfoResp(): GetJointInfoResp {
  return { joints: [] };
}

export const GetJointInfoResp: MessageFns<GetJointInfoResp> = {
  encode(message: GetJointInfoResp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.joints) {
      JointInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetJointInfoResp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetJointInfoResp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.joints.push(JointInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetJointInfoResp {
    return { joints: gt.Array.isArray(object?.joints) ? object.joints.map((e: any) => JointInfo.fromJSON(e)) : [] };
  },

  toJSON(message: GetJointInfoResp): unknown {
    const obj: any = {};
    if (message.joints?.length) {
      obj.joints = message.joints.map((e) => JointInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetJointInfoResp>, I>>(base?: I): GetJointInfoResp {
    return GetJointInfoResp.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetJointInfoResp>, I>>(object: I): GetJointInfoResp {
    const message = createBaseGetJointInfoResp();
    message.joints = object.joints?.map((e) => JointInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConsoleWriteReq(): ConsoleWriteReq {
  return { message: "" };
}

export const ConsoleWriteReq: MessageFns<ConsoleWriteReq> = {
  encode(message: ConsoleWriteReq, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined && message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsoleWriteReq {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsoleWriteReq();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsoleWriteReq {
    return { message: isSet(object.message) ? gt.String(object.message) : "" };
  },

  toJSON(message: ConsoleWriteReq): unknown {
    const obj: any = {};
    if (message.message !== undefined && message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsoleWriteReq>, I>>(base?: I): ConsoleWriteReq {
    return ConsoleWriteReq.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsoleWriteReq>, I>>(object: I): ConsoleWriteReq {
    const message = createBaseConsoleWriteReq();
    message.message = object.message ?? "";
    return message;
  },
};

declare const self: any | undefined;
declare const window: any | undefined;
declare const global: any | undefined;
const gt: any = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw "Unable to locate global object";
})();

function bytesFromBase64(b64: string): Uint8Array {
  if ((gt as any).Buffer) {
    return Uint8Array.from(gt.Buffer.from(b64, "base64"));
  } else {
    const bin = gt.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((gt as any).Buffer) {
    return gt.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(gt.String.fromCharCode(byte));
    });
    return gt.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
